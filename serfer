#!/usr/bin/env php
<?php

/**
 * Serfer
 * 
 * Episode/Series filename re-namer and information lookup script
 *
 * @author    Rob M Frawley 2nd
 * @copyright 2009-2014 Inserrat Technologies, LLC
 * @license   MIT License
 */

require_once 'Console/GetoptPlus.php';

Config::setRuntime('php.timezone', 'America/New_York');
Config::setRuntime('script.verbosity', 2);
Config::setRuntime('script.mode', 'tv');
Config::setRuntime('script.stdout', fopen('php://stdout', 'w'));
Config::setRuntime('script.stdin', fopen('php://stdin', 'r'));
Config::set('tpl.filepath.tv', '${seriesname}/Season ${episodeseason}/${seriesname} S${episodeseason}E${episodenumber} ${episodename}');
Config::set('tpl.filepath.movie', '${moviename}/${moviename} [${movieyear}] [${movieimdb}]');
Config::set('dirpath.input', '/Users/rmf/Torrents/Done/');
Config::set('dirpath.output', '/Users/rmf/Torrents/Organized/');
Config::set('files.extensions', 'mp4,mkv,avi,mov');

/**
 * Config class
 * Contains runtime and script config values
 */
class Config
{
    /**
     * @var array
     */
    static public $runtime = [];

    /**
     * @var array
     */
    static public $config = [];

    /**
     * @param  string $key
     * @param  mixed  $value
     * @return mixed
     */
    static public function setRuntime($key, $value)
    {
        self::$runtime[(string)$key] = $value;

        return $value;
    }

    /**
     * @param  string $key
     * @return mixed
     */
    static public function getRuntime($key)
    {
        if (!array_key_exists($key, self::$runtime)) {
            throw new Exception('Invalid runtime config key provided: ' . $key);
        }

        return self::$runtime[$key];
    }

    /**
     * @param  string $key
     * @param  mixed  $value
     * @return mixed
     */
    static public function set($key, $value)
    {
        self::$config[(string)$key] = $value;

        return $value;
    }

    /**
     * @param  string $key
     * @return mixed
     */
    static public function get($key)
    {
        if (!array_key_exists($key, self::$config)) {
            throw new Exception('Invalid runtime config key provided');
        }

        return self::$config[$key];
    }
}

/**
 * Console class
 */
class Console 
{
    /**
     * @var array
     */
    static public $colors = [
        'k' => '1;30',
        'K' => '0;30',
        'r' => '1;31',
        'R' => '0;31',
        'g' => '1;32',
        'G' => '0;32',
        'y' => '1;33',
        'Y' => '0;33',
        'b' => '1;34',
        'B' => '0;34',
        'p' => '1;35',
        'P' => '0;35',
        'c' => '1;36',
        'C' => '0;36',
        'w' => '1;37',
        'W' => '0;37',
    ];

    /**
     * @var array
     */
    static public $buffer = [];

    /**
     * @param  string $out
     * @return string
     */
    static public function colorize($out = '')
    {
        foreach (self::$colors as $search => $replace) {
            $out = str_replace('%'.$search, "\033[${replace}m", $out);
        }

        $out = $out . "\033[0m";

        return $out;
    }

    /**
     * @param string  $out
     * @param integer $level
     * @param boolean $nl
     */
    static public function out($out = '', $level = 1, $nl = false)
    {
        if ($level > Config::getRuntime('script.verbosity')) {
            return;
        }

        $out = self::colorize($out);

        if ($nl === true) {
            $out = $out . "\n";
        }
        
        @fwrite(Config::getRuntime('script.stdout'), $out);
    }

    /**
     * @param string  $out
     * @param integer $level
     */
    static public function outl($out = '', $level = 1)
    {
        self::out($out, $level, true);
    }

    static public function prompt($out = '', $default = null)
    {
        if ($default !== null) {
            $out = '%w' . $out . ' %W['.$default.']: %w';
        } else {
            $out = '%w' . $out . ' %W: %w';
        }
        
        self::out($out, 0);
        
        $input = trim(fgets(Config::getRuntime('script.stdin')));
        if (empty($input)) {
            $input = $default;
        }

        return $input;
    }

    /**
     * @param string  $out
     * @param integer $level
     */
    static public function buffer($out = '', $level = 1)
    {
        if ($level > Config::getRuntime('script.verbosity')) {
            return;
        }

        self::$buffer[] = $out;
    }

    /**
     * @param boolean $nl
     */
    static public function flush($nl = true, $align = true)
    {
        if ($align === true) {
            self::bufferAlign();
        }

        while (null !== ($out = array_shift(self::$buffer))) {
            self::out($out, Config::getRuntime('script.verbosity'), $nl);
        }
    }

    static public function bufferAlign()
    {
        $leftLen = 0;
        $indexes = [];

        foreach (self::$buffer as $i => $b) {
            $matches = [];
            $result = preg_match('#\[([\.\s:]){3}\]#', $b, $matches, PREG_OFFSET_CAPTURE);

            if ($result !== 1) {
                continue;
            }

            $indexes[] = $i;

            if ($leftLen < $matches[0][1]) {
                $leftLen = $matches[0][1];
            }

        }

        foreach ($indexes as $i) {
            $b = self::$buffer[$i];

            $matches = [];
            $result = preg_match('#\[([\.\s:]){3}\](.*?)#', $b, $matches, PREG_OFFSET_CAPTURE);

            $left  = substr($b, 0, $matches[0][1]);
            $type  = substr($b, $matches[0][1], 5);
            $right = substr($b, $matches[2][1]);

            switch ($type) {
                case '[   ]':
                    $left = str_pad($left, $leftLen+3, ' ', STR_PAD_RIGHT);
                    break;
                case '[...]':
                    $left = str_pad($left, $leftLen+3, '.', STR_PAD_RIGHT);
                    break;
                case '[:  ]':
                    $left = $left . ' :';
                    $left = str_pad($left, $leftLen+3, ' ', STR_PAD_RIGHT);
                    break;
                case '[  :]':
                    $left = str_pad($left, $leftLen, ' ', STR_PAD_RIGHT);
                    $left = $left . ' : ';
                    break;
            }

            self::$buffer[$i] = $left . $right;

        }
    }
}

class SerfersQueue
{
    static public $queue = [];

    static public function add($item)
    {
        self::$queue[] = $item;
    }

    static public function shift()
    {
        return array_shift(self::$queue);
    }
}

abstract class Serfers
{
    abstract protected function handleItem($item);

    public function go()
    {
        $items    = $this->scanDirectory(Config::get('dirpath.input'));
        $count    = count($items);
        $skipRest = false;

        for ($i = 0; $i < $count; $i++) {
            $item = $items[$i];
            $this->showItemHeader($i, $count);

            $skipRest = $this->handleItem($item);

            if ($skipRest === true) {
                break;
            }
        }
    }

    protected function scanDirectory($dir, $subDir = '.') 
    {
        $items = [];
        $acceptedExts = explode(',', Config::get('files.extensions'));

        foreach (scandir($dir) as $item) {

            if ($item == '.' || $item == '..' || substr($item, 0, 1) == '.') {
                continue;
            }

            if (is_dir($dir.$item)) {
                $items = array_merge($items, (array)$this->scanDirectory($dir.$item.DIRECTORY_SEPARATOR, $subDir.DIRECTORY_SEPARATOR.$item));
            } else {
                if (!in_array(pathinfo($item, PATHINFO_EXTENSION), $acceptedExts)) {
                    continue;
                }
                if ($subDir === null) {
                    $items[] = $item;
                } else {
                    $items[] = $subDir.DIRECTORY_SEPARATOR.$item;
                }
            }
        }

        return $items;
    }

    protected function showItemHeader($i, $count)
    {
        Console::outl('%r[ %R'.str_pad($i+1, 3, '0', STR_PAD_LEFT).' of '.str_pad($count, 3, '0', STR_PAD_LEFT).'%r ]');
    }
}

class SerfersTV extends Serfers
{
    protected function handleItem($item)
    {
        list($show, $season, $episode, $date) = 
            $this->parseItem($item)
        ;

        $loop     = true;
        $skip     = false;
        $skipRest = false;

        while($loop === true) {

            list($show, $season, $episode, $title, $date, $lookupSuccess) = 
                $this->doLookupTVEpisode($show, $season, $episode, $date)
            ;
            
            Console::buffer();
            Console::buffer('Show%k[...]%w'.$show);

            if ($lookupSuccess === true) {
                Console::buffer('Lookup%k[...]%gSuccess');
            } else {
                Console::buffer('Lookup%k[...]%rFailure');
            }

            if ($season === null) {
                Console::buffer('Season%k[...]%w[null]');
            } else {
                Console::buffer('Season%k[...]%w'.$season);
            }

            if ($episode === null) {
                Console::buffer('Episode%k[...]%w[null]');
            } else {
                Console::buffer('Episode%k[...]%w'.$episode);
            }

            if ($title === null) {
                Console::buffer('Title%k[...]%w[null]');
            } else {
                Console::buffer('Title%k[...]%w'.$title);
            }
            Console::buffer('Filepath%k[...]%w'.$item);

            Console::buffer();

            Console::buffer('Actions:');
            Console::buffer("\ts. Edit Season");
            Console::buffer("\te. Edit Episode");
            Console::buffer("\th. Edit Show");
            Console::buffer("\tt. Edit Title");
            Console::buffer("\tr. Re-parse Filename");
            Console::buffer("\tk. Skip");
            Console::buffer("\tK. Skip the Rest");
            Console::buffer("\tD. Delete");
            Console::buffer("\tc. Continue");

            Console::buffer();
            Console::flush();

            $response = Console::prompt('What would you like to do?', 'c');

            switch ($response) {
                case 's':
                    $response = Console::prompt('Enter the season number');
                    $season = $response;
                    break;
                case 'e':
                    $response = Console::prompt('Enter the episode number');
                    $episode = $response;
                    break;
                case 'h':
                    $response = Console::prompt('Enter the show name');
                    $show = $response;
                    break;
                case 't':
                    $response = Console::prompt('Enter the show title');
                    $title = $response;
                    break;
                case 'r':
                    list($show, $season, $episode, $date) = 
                        $this->parseItem($item)
                    ;
                    break;
                case 'k':
                    $skip = true;
                    break;
                case 'K':
                    $skipRest = true;
                    break;
                case 'c':
                    $loop = false;
                    break;
            }

            if ($skip === true || $skipRest === true) {
                break;
            }

        }

        if ($skip === true || $skipRest === true) {
            return $skipRest;
        }

        SerfersQueue::add($item);

        return false;
    }

    protected function parseItem($filepath)
    {
        $pattern  = '#\.?/?(.*?)/?season ?([0-9]{1,2})[ /]?episode ?([0-9]{1,2})#i';
        $matches  = [];

        $return = preg_match($pattern, $filepath, $matches, PREG_OFFSET_CAPTURE);

        if ($return === 1) {
            return [
                isset($matches[1][0]) ? $matches[1][0] : $filepath,
                isset($matches[2][0]) ? $matches[2][0] : null,
                isset($matches[3][0]) ? $matches[3][0] : null,
                null
            ];
        }

        $pattern  = '#\.?/?(.*?)([0-9]{4}\.[0-9]{2}\.[0-9]{2})#i';
        $matches  = [];

        $return = preg_match($pattern, $filepath, $matches, PREG_OFFSET_CAPTURE);

        if ($return === 1) {
            return [
                isset($matches[1][0]) ? $matches[1][0] : $filepath,
                null,
                null,
                isset($matches[2][0]) ? $matches[2][0] : null
            ];
        }

        $pattern  = '#(.*?) ?s?([0-9]{1,2}) ?[xe\.]([0-9]{1,2})#i';
        $matches  = [];

        $return = preg_match($pattern, $filepath, $matches, PREG_OFFSET_CAPTURE);

        if ($return === 1) {
            return [
                isset($matches[1][0]) ? $matches[1][0] : $filepath,
                isset($matches[2][0]) ? $matches[2][0] : null,
                isset($matches[3][0]) ? $matches[3][0] : null,
                null
            ];
        }

        $pattern  = '#(.*?)\b([0-9]{1,2})([0-9]{2})\b#i';
        $matches  = [];

        $return = preg_match($pattern, $filepath, $matches, PREG_OFFSET_CAPTURE);

        if ($return === 1) {
            return [
                isset($matches[1][0]) ? $matches[1][0] : $filepath,
                isset($matches[2][0]) ? $matches[2][0] : null,
                isset($matches[3][0]) ? $matches[3][0] : null,
                null
            ];
        }

        return [
            $filepath,
            null,
            null,
            null
        ];
    }

    protected function doLookupTVEpisode($show, $season, $episode, $title)
    {
        $traktApiKey = Config::getRuntime('lookup.api.trakt');

        $imdbID = $this->doLookupTVShow($show);

        if ($show === null) {
            return [null, null, null];
        }

        $api = "http://api.trakt.tv/show/episode/summary.json/$traktApiKey/$imdbID/$season/$episode";

        $json = @file_get_contents($api);
        $info = @json_decode($json);

        return [
            @$info->show->title     ? $info->show->title     : $show,
            @$info->episode->season ? $info->episode->season : $season,
            @$info->episode->number ? $info->episode->number : $episode,
            @$info->episode->title  ? $info->episode->title  : $title,
            null,
            @$info->episode->title  ? true                   : false,
        ];
    }

    protected function doLookupTVShow($show)
    {
        $traktApiKey = Config::getRuntime('lookup.api.trakt');

        $api = "http://api.trakt.tv/search/shows.json/$traktApiKey?query=".urlencode($show);

        $json = @file_get_contents($api);
        $info = @json_decode($json);

        if (!count($info) > 0) {
            return null;
        }

        return @$info[0]->imdb_id;
    }
}

class SerfersMovie extends Serfers
{
    protected function handleItem($item)
    {

    }
}

/**
 * main function handles the script from beginning to end
 */
function main()
{
    date_default_timezone_set(Config::getRuntime('php.timezone'));

    try {
        $optConfig = [
            'options' => [
                [
                    'long'  => 'tv',
                    'short' => 't',
                    'type'  => 'noarg',
                    'desc'  => 'Mode: Parse TV shows',
                ],
                [
                    'long'  => 'movie',
                    'short' => 'm',
                    'type'  => 'noarg',
                    'desc'  => 'Mode: parse movies',
                ],
                [
                    'long'  => 'verbosity',
                    'short' => 'v',
                    'type'  => 'mandatory',
                    'desc'  => 'Verbosity 0, 1, or 2',
                ],
                [
                    'long'  => 'in',
                    'short' => 'i',
                    'type'  => 'mandatory',
                    'desc'  => 'Input directory',
                ],
                [
                    'long'  => 'out',
                    'short' => 'o',
                    'type'  => 'mandatory',
                    'desc'  => 'Output directory',
                ],
                [
                    'long'  => 'extensions',
                    'short' => 'e',
                    'type'  => 'mandatory',
                    'desc'  => 'Acceptable extensions',
                ]
            ]
        ];
        $options = Console_Getoptplus::getoptplus($optConfig);
    }
    catch (Console_GetoptPlus_Exception $e) {
        echo $e->getCode() . ': ' . $e->getMessage();
        die();
    }

    Console::buffer();
    Console::buffer('%wSerfers[   ]Series/Episode/movie File Renamer and lookup Script');
    Console::buffer('%WVersion[  :]0.6.0');
    Console::buffer('%WWritten By[  :]Rob Frawley 2nd');
    Console::buffer('%WCopyright[  :]2009-2014 Inserrat Technologies, LLC');
    Console::buffer('%WLicense[  :]MIT License');
    Console::buffer();
    Console::flush();

    foreach ($options[0] as $o) {
        switch ($o[0]) {
            case 'verbosity':
            case 'v':
                Config::setRuntime('script.verbosity', $o[1]);
                break;
            case 'extensions':
            case 'e':
                Config::set('files.extensions', $o[1]);
                break;
            case 'in':
            case 'i':
                Config::set('dirpath.input', $o[1]);
                break;
            case 'out':
            case 'o':
                Config::set('dirpath.output', $o[1]);
                break;
            case '--tv':
            case 't':
                Config::setRuntime('script.mode', 'tv');
                break;
            case '--movie':
            case 'm':
                Config::setRuntime('script.mode', 'movie');
                break;
        }
    }

    if (file_exists(__DIR__.DIRECTORY_SEPARATOR.'lookup.api.trakt')) {
        Config::setRuntime('lookup.api.trakt', file_get_contents(__DIR__.DIRECTORY_SEPARATOR.'lookup.api.trakt'));
    } else {
        Config::setRuntime('lookup.api.trakt', 'Undefined');
    }
    
    Console::buffer('%bCONFIG %Bscript.timezone[  :]%W'.Config::getRuntime('php.timezone'), 2);
    Console::buffer('%bCONFIG %Bscript.verbosity[  :]%W'.Config::getRuntime('script.verbosity'), 2);
    Console::buffer('%bCONFIG %Bscript.mode[  :]%W'.Config::getRuntime('script.mode'), 1);
    Console::buffer('%bCONFIG %Btpl.filepath.tv[  :]%W'.Config::get('tpl.filepath.tv'), 2);
    Console::buffer('%bCONFIG %Btpl.filepath.movie[  :]%W'.Config::get('tpl.filepath.movie'), 2);
    Console::buffer('%bCONFIG %Bdirpath.input[  :]%W'.Config::get('dirpath.input'), 1);
    Console::buffer('%bCONFIG %Bdirpath.output[  :]%W'.Config::get('dirpath.output'), 1);
    Console::buffer('%bCONFIG %Bfiles.extensions[  :]%W'.Config::get('files.extensions'), 2);
    Console::buffer('%bCONFIG %Blookup.api.trakt[  :]%W'.Config::getRuntime('lookup.api.trakt'), 2);
    Console::buffer();
    Console::flush();

    if (Config::getRuntime('script.mode') == 'tv') {
        $handler = new SerfersTV();
    } else {
        $handler = new ServersMovie();
    }

    $handler->go();

}

/* run main script function: go */
main();

?>